    %% Matlab code to perform relative pose estimation
% Generated by Michael Sanne SNNMIC003
% 4th Year Engineering Thesis at The University of Cape Town
% 2017/10/20
rng('default');
clear;
close all;

    %% Loads Images from Data/1LoopDown Folder
    % Load images and camera intrinsics from file
    images = imageDatastore('Data/1LoopDown/imagesUndistort_1loopDown');
    K = load('Data/1LoopDown/camIntrinsicDown.txt')';
    cameraParams = cameraParameters('IntrinsicMatrix', K);
    
    % Load ground truth Data as groundTruthPoses
    ViconMatlabImport;
    
    % Instantiate a view set to keep track of poses
    v = viewSet;
    vId = 1;

    %% Import first 2 images
    I1 = rgb2gray(readimage(images,1));
    I2 = rgb2gray(readimage(images,2));

    %% Estimate Pose of first 2 images and retrieve P Matrices

    % Detect Features for Image 1
    mtsparm = 250;
    points1 = detectSURFFeatures(I1, 'MetricThreshold', mtsparm);
    feat1 = extractFeatures(I1, points1);

    % Detect Features for Image 2
    points2 = detectSURFFeatures(I2, 'MetricThreshold', mtsparm);
    feat2 = extractFeatures(I2, points2);

    % Match Features between image 1 and image 2 - Putative matches
    mpairs_12 = matchFeatures(feat1, feat2, 'Unique', true);
    mpoints1_12 = points1(mpairs_12(:,1));  mpoints2_12 = points2(mpairs_12(:,2));  

    % Estimate camera pose in which 80% of the views are in front of the
    % camera
    for i=1:1000
      
      % Estimate the essential matrix in which more than 30% of points are
      % kept
      [E_12, minf_12] = estimateEssentialMatrix(mpoints1_12, mpoints2_12, cameraParams);
      if sum(minf_12)/numel(minf_12)<0.3, continue; end

      % Calculate Camera pose from Essential matrix
      [orient_12,loc_12,vpf_12] = relativeCameraPose(E_12, cameraParams, mpoints1_12(minf_12), mpoints2_12(minf_12));
      if vpf_12>0.8, break; end
    end
    if vpf_12<=0.8, warning('Problem with camera pose estimate?'); end

    % Keep only the inlier points from the estimated essential matrix
    mpointsMin1_12 = mpoints1_12(minf_12);
    mpointsMin2_12 = mpoints2_12(minf_12);
    mpairs_12 = mpairs_12(minf_12,:);
    
    % Generate Camera matrices
    R1_12 = eye(3);  t1_12 = zeros(1,3);
    P1_12 = cameraMatrix(cameraParams, R1_12, t1_12);
    [R2_12,t2_12] = cameraPoseToExtrinsics(orient_12, loc_12);
    P2_12 = cameraMatrix(cameraParams, R2_12, t2_12);

    % Add estimated pose values to the view set
    [orientation,location] = extrinsicsToCameraPose(R1_12,t1_12);
    v = addView(v, vId, 'Points', points1, 'Orientation', ...
        orientation, 'Location', location);
    vId = vId + 1;

    [orientation,location] = extrinsicsToCameraPose(R2_12,t2_12);
    v = addView(v, vId, 'Points', points2, 'Orientation', ...
        orientation, 'Location', location);
    vId = vId + 1;

    % Add matched point connections between the views to the viewset
    v = addConnection(v, vId-2, vId-1, 'Matches', mpairs_12(minf_12, :));

    %% Loop
for i = 3:10%numel(images.Files)
close all;
rng('default');
    %% Import next image and Determine Relative Pose Between 2 and 3
    I3 = rgb2gray(readimage(images,i));

    % Detect Features Image i and extract features
    points3 = detectSURFFeatures(I3, 'MetricThreshold', mtsparm);
    feat3 = extractFeatures(I3, points3);
    
    % Putative matches between image i and image i-1
    mpairs_23 = matchFeatures(feat2, feat3, 'Unique', true);
    mpoints2_23 = points2(mpairs_23(:,1));  mpoints3_23 = points3(mpairs_23(:,2));

    % Pose estimation
    for i=1:1000

      % Estimate the essential matrix with minimum 30% inliers
      [E_23, minf_23] = estimateEssentialMatrix(mpoints2_23, mpoints3_23, cameraParams);
      if sum(minf_23)/numel(minf_23)<0.3, continue; end

      % Calculate Camera pose from the essential matrix
      [orient_23,loc_23,vpf_23] = relativeCameraPose(E_23, cameraParams, mpoints2_23(minf_23), mpoints3_23(minf_23));
      if vpf_23>0.8, break; end
    end
    if vpf_23<=0.8, warning(sprintf('Problem with camera pose estimate? %s', num2str(vId))); 
        subplot(1,2,1);  ih = imagesc(I2);  colormap(gray);  hold on;  ph = plot(points2);  hold off;
        subplot(1,2,2);  ih = imagesc(I3);  colormap(gray);  hold on;  ph = plot(points3);  hold off;
        fh = figure; showMatchedFeatures(I2, I3, mpoints2_23(minf_23), mpoints3_23(minf_23), 'falsecolor'); 
        fh = figure; showMatchedFeatures(I2, I3, mpoints2_23, mpoints3_23, 'falsecolor');
        continue;
    end
    
    % Only compare inlier points
    mpointsMin2_23 = mpoints2_23(minf_23);
    mpointsMin3_23 = mpoints3_23(minf_23);
    mpairs_23 = mpairs_23(minf_23,:);
    
    % Camera matrices from the estimated pose
    R2_23 = eye(3);  t2_23 = zeros(1,3);
    P2_23 = cameraMatrix(cameraParams, R2_23, t2_23);
    [R3_23,t3_23] = cameraPoseToExtrinsics(orient_23, loc_23);
    P3_23 = cameraMatrix(cameraParams, R3_23, t3_23);
      
    %% Match points for 2D-2D correspondences using common image
   
    % Find intersecting points in common image
    [~, ia, ib] = intersect(mpointsMin2_12.Location,mpointsMin2_23.Location, 'rows');
    points1_123 = mpointsMin1_12(ia,:);
    points2_123 = mpointsMin2_12(ia,:);
    points2b_123 = mpointsMin2_23(ib,:);
    points3_123 = mpointsMin3_23(ib,:);

    %% Get X and X' form from inlier points
    wp_12 = triangulate(points1_123, points2_123, P1_12, P2_12);
    wp_23 = triangulate(points2b_123, points3_123, P2_23, P3_23);
    
    %% Determine Scale using distance between 2 points
    
    % Find distance between corresponding points in world plane X from plane 1 and 2 
    scaleVector = zeros(1, length(points1_123)-1);
    for j = 1:length(points1_123)-1
         wp1_12 = triangulate(points1_123(j), points2_123(j), P1_12, P2_12);
         wp2_12 = triangulate(points1_123(j+1), points2_123(j+1), P1_12, P2_12);
         distance1_1 = sqrt ((wp2_12(1)-wp1_12(1))^2+(wp2_12(2)-wp1_12(2))^2+(wp2_12(3)-wp1_12(3))^2);
         
         wp1_23 = triangulate(points2b_123(j), points3_123(j), P2_23, P3_23);
         wp2_23 = triangulate(points2b_123(j+1), points3_123(j+1), P2_23, P3_23);
         distance2_1 = sqrt ((wp2_23(1)-wp1_23(1))^2+(wp2_23(2)-wp1_23(2))^2+(wp2_23(3)-wp1_23(3))^2);

        scale1 = distance1_1/distance2_1;

        scaleVector(1, j) = scale1;
    end
    
    % Compute scale average between 2 planes
    scale = trimmean(scaleVector, 50);

    %% Perform Rotation from X" to X
    % Rotate Image 2 from [I 0] to [R t]
    R2_23 = R2_12;
    t2_23 = t2_12;
    P2_23 = cameraMatrix(cameraParams, R2_23, t2_23);
    
    % Find [R t] in Coorinate frame 1
    t3_23 = double((R3_23*t2_23')'+scale*t3_23);
    R3_23 = R3_23*R2_23;
    P3_23 = cameraMatrix(cameraParams, R3_23, t3_23);
    
    % Add new view to the viewSet and add connection through matched points
    [orientation,location] = extrinsicsToCameraPose(R3_23,t3_23);
    v = addView(v, vId, 'Points', points3, 'Orientation', ...
        orientation, 'Location', location);
    vId = vId + 1;
    
    v = addConnection(v, vId-2, vId-1, 'Matches', mpairs_23);
    
    %% Get X and X' in X coordinate space
    wpi_12 = triangulate(points1_123, points2_123, P1_12, P2_12);
    wpi_23 = triangulate(points2b_123, points3_123, P2_23, P3_23);
    
    %% Plot
    
    % Plot the most recent camera poses (3) with their respective world
    % points
    figure;  %axis([-10, 10, -10, 10, 0, 20]);  
    view(gca, 3);
    set(gca, 'CameraUpVector', [0, -1, 0]);  camorbit(gca, -120, 0, 'data', [0, 1, 0]);
    grid on;  xlabel('X');  ylabel('Y');  zlabel('Z');  hold on;
    pcsize = 0.5;
    plotCamera('Size', pcsize, 'Location', t1_12, 'Orientation', R1_12, 'Color', 'b', 'Opacity', 0);
    plotCamera('Size', pcsize, 'Location', t2_23, 'Orientation', R2_23, 'Color', 'g', 'Opacity', 0);
    plotCamera('Size', pcsize, 'Location', t3_23, 'Orientation', R3_23, 'Color', 'r', 'Opacity', 0);
    scatter3(wpi_12(:,1)',wpi_12(:,2)',wpi_12(:,3)','g.');
    scatter3(wpi_23(:,1)',wpi_23(:,2)',wpi_23(:,3)','r.');
    title('Previous 3 Cameras and matched points');

    % Plot all camera poses from the viewset in one image
    figure;  %axis([-10, 10, -10, 10, 0, 20]);  
    view(gca, 3);
    set(gca, 'CameraUpVector', [0, -1, 0]);  camorbit(gca, -120, 0, 'data', [0, 1, 0]);
    grid on;  xlabel('X');  ylabel('Y');  zlabel('Z');  hold on;
    pcsize = 0.5;
    camPoses = poses(v);
    plotCamera(camPoses, 'Size', 0.2);
    hold on
    sh = scatter3(xyzPoints(:,1)', xyzPoints(:,2)', xyzPoints(:,3)', 'b.');
    title('Camera Poses with Bundle Adjustment');
    
     %% Remap Variables for loop
    
    I1 = I2;
    I2 = I3;

    points1 = points2;
    feat1 = feat2;

    points2 = points3;
    feat2 = feat3;

    mpairs_12 = mpairs_23;
    mpointsMin1_12 = mpointsMin2_23;
    mpointsMin2_12 = mpointsMin3_23;
    
    R1_12 = R2_23;
    t1_12 = t2_23;
    P1_12 = P2_23;
    R2_12 = R3_23;
    t2_12 = t3_23;
    P2_12 = P3_23;

end
